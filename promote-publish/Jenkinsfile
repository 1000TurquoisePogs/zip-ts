#!groovy

/**
 * This program and the accompanying materials are made available under the terms of the
 * Eclipse Public License v2.0 which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-v20.html
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Copyright IBM Corporation 2018, 2019
 */

node('ibm-jenkins-slave-nvm') {
  def lib = library("jenkins-library@staging").org.zowe.jenkins_shared_library

  def ZOWE_RELEASE_REPOSITORY = 'libs-release-local'
  def ZOWE_RELEASE_PATH = '/org/zowe'
  def ZOWE_RELEASE_FILEPATTERN = "zowe-*.pax"
  def ZOWE_RELEASE_SMPE_PAX_FILEPATTERN = "AZWE*.pax.Z"
  def ZOWE_RELEASE_SMPE_README_FILEPATTERN = "AZWE*.txt"
  def ZOWE_RELEASE_CLI_FILEPATTERN = "zowe-cli-package-*.zip"

  def pipeline = lib.pipelines.generic.GenericPipeline.new(this)

  def isFormalRelease = false
  def releaseFilePath
  def releaseArtifacts = readJSON(text:'{}')
  def smpeFmid

  pipeline.admins.add("jackjia", "markackert")

  // we have extra parameters for integration test
  pipeline.addBuildParameters(
    string(
      name: 'ZOWE_BUILD_REPOSITORY',
      description: 'Zowe successful build repository',
      defaultValue: 'libs-snapshot-local',
      trim: true,
      required: true
    ),
    string(
      name: 'ZOWE_BUILD_NAME',
      description: 'Zowe successful build name',
      defaultValue: 'zowe-install-packaging :: master',
      trim: true,
      required: true
    ),
    string(
      name: 'ZOWE_BUILD_NUMBER',
      description: 'REQUIRED if ZOWE_BUILD_RC_PATH is empty. Zowe successful build number',
      defaultValue: '',
      trim: true
    ),
    string(
      name: 'ZOWE_BUILD_RC_PATH',
      description: 'REQUIRED if ZOWE_BUILD_NUMBER is empty. Zowe RC build artifactory download path. If the build original file has been removed from artifactory, we can promote any existing file. Example: libs-release-local/org/zowe/0.9.3-RC2/zowe-0.9.3-RC2.pax',
      defaultValue: '',
      trim: true
    ),
    string(
      name: 'ZOWE_CLI_BUILD_REPOSITORY',
      description: 'Zowe CLI successful build repository',
      defaultValue: 'libs-snapshot-local',
      trim: true,
      required: true
    ),
    string(
      name: 'ZOWE_CLI_BUILD_NAME',
      description: 'Zowe CLI successful build name',
      defaultValue: 'Zowe CLI Bundle :: master',
      trim: true,
      required: true
    ),
    string(
      name: 'ZOWE_CLI_BUILD_NUMBER',
      description: 'REQUIRED if ZOWE_CLI_BUILD_RC_PATH is empty. Zowe CLI successful build number',
      defaultValue: '',
      trim: true
    ),
    string(
      name: 'ZOWE_CLI_BUILD_RC_PATH',
      description: 'REQUIRED if ZOWE_CLI_BUILD_NUMBER is empty. Zowe CLI build artifactory download path. If the build original file has been removed from artifactory, we can promote any existing file. Example: libs-release-local/org/zowe/0.9.3-RC2/zowe-cli-package-0.9.3.zip',
      defaultValue: '',
      trim: true
    ),
    string(
      name: 'ZOWE_RELEASE_CATEGORY',
      description: 'REQUIRED. Zowe release category. For example, stable',
      defaultValue: 'stable',
      trim: true,
      required: true
    ),
    string(
      name: 'ZOWE_RELEASE_VERSION',
      description: 'REQUIRED. Zowe release version without prefix v. For example, 0.9.0',
      defaultValue: '',
      trim: true,
      required: true
    ),
    // >>>>>>>> SSH access of testing server zOSaaS layer
    string(
      name: 'PUBLISH_SSH_HOST',
      description: 'Host of publishing server',
      defaultValue: 'wash.zowe.org',
      trim: true,
      required: true
    ),
    string(
      name: 'PUBLISH_SSH_PORT',
      description: 'SSH port of publishing server',
      defaultValue: '22',
      trim: true,
      required: true
    ),
    credentials(
      name: 'PUBLISH_SSH_CREDENTIAL',
      description: 'The SSH credential used to connect publishing server',
      credentialType: 'com.cloudbees.plugins.credentials.impl.UsernamePasswordCredentialsImpl',
      defaultValue: 'ssh-zowe-publish',
      required: true
    ),
    string(
      name: 'PUBLISH_DIRECTORY',
      description: 'Publishing directory',
      defaultValue: '/var/www/projectgiza.org/builds',
      trim: true,
      required: true
    ),
    string(
      name: 'CODE_SIGNING_KEY_PASSPHRASE',
      description: 'Key ID and passphrase to sign the build',
      credentialType: 'com.cloudbees.plugins.credentials.impl.UsernamePasswordCredentialsImpl',
      defaultValue: 'code-signing-key-passphrase-jack',
      required: false
    )
  )

  pipeline.setup(
    packageName: 'org.zowe',
    github: [
      email                      : lib.Constants.DEFAULT_GITHUB_ROBOT_EMAIL,
      usernamePasswordCredential : lib.Constants.DEFAULT_GITHUB_ROBOT_CREDENTIAL,
    ],
    artifactory: [
      url                        : lib.Constants.DEFAULT_ARTIFACTORY_URL,
      usernamePasswordCredential : lib.Constants.DEFAULT_ARTIFACTORY_ROBOT_CREDENTIAL,
    ]
  )

  pipeline.build(
    name          : "Validate",
    timeout       : [time: 5, unit: 'MINUTES'],
    isSkippable   : false,
    operation     : {
      if (!params.ZOWE_BUILD_NAME) {
        error "ZOWE_BUILD_NAME is required to promote build."
      }
      if (!params.ZOWE_BUILD_NUMBER && !params.ZOWE_BUILD_RC_PATH) {
        error "ZOWE_BUILD_NUMBER or ZOWE_BUILD_RC_PATH is required to promote build."
      }
      if (!params.ZOWE_CLI_BUILD_NAME) {
        error "ZOWE_CLI_BUILD_NAME is required to promote build."
      }
      if (!params.ZOWE_CLI_BUILD_NUMBER && !params.ZOWE_CLI_BUILD_RC_PATH) {
        error "ZOWE_CLI_BUILD_NUMBER or ZOWE_CLI_BUILD_RC_PATH is required to promote build."
      }
      if (!params.ZOWE_RELEASE_CATEGORY) {
        error "ZOWE_RELEASE_CATEGORY is required to promote build."
      }
      if (!params.ZOWE_RELEASE_VERSION) {
        error "ZOWE_RELEASE_VERSION is required to promote build."
      }

      echo "Checking if ${params.ZOWE_RELEASE_VERSION} is a valid semantic version ..."
      // validate release version scheme
      // thanks semver/semver, this regular expression comes from
      // https://github.com/semver/semver/issues/232#issuecomment-405596809
      if (!(params.ZOWE_RELEASE_VERSION ==~ /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/)) {
        error "${params.ZOWE_RELEASE_VERSION} is not a valid semantic version."
      }
      if (params.ZOWE_RELEASE_VERSION ==~ /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)$/) {
        isFormalRelease = true
        echo ">>>> Version ${params.ZOWE_RELEASE_VERSION} is considered as a FORMAL RELEASE."
      } else {
        echo ">>>> Version ${params.ZOWE_RELEASE_VERSION} is NOT considered as a FORMAL RELEASE."
      }

      // this is the target Artifactory path will be released to
      releaseFilePath = "${ZOWE_RELEASE_REPOSITORY}${ZOWE_RELEASE_PATH}/${params.ZOWE_RELEASE_VERSION}".toString()

      // check artifactory release path
      echo "Checking if ${params.ZOWE_RELEASE_VERSION} already exists in Artifactory ..."
      def versionOnArtifactory
      try {
        versionOnArtifactory = pipeline.artifactory.getArtifact(releaseFilePath)
      } catch (e) {
        // ignore errors
      }
      if (versionOnArtifactory && versionOnArtifactory.path) {
        error "Zowe version ${params.ZOWE_RELEASE_VERSION} already exists (${releaseFilePath})"
      } else {
        echo ">>>> Target artifactory folder ${releaseFilePath} doesn't exist, may proceed."
      }

      // find the Zowe build number will be promoted
      releaseArtifacts['zowe'] = [:]
      releaseArtifacts['zowe']['target'] = "zowe-${params.ZOWE_RELEASE_VERSION}.pax".toString()
      if (params.ZOWE_BUILD_RC_PATH) {
        def artifact = pipeline.artifactory.getArtifact(params.ZOWE_BUILD_RC_PATH)
        if (artifact['build.name'].contains('zowe-promote-publish') &&
          artifact['build.parentName'] && artifact['build.parentNumber']) {
          artifact['build.name'] = artifact['build.parentName']
          artifact['build.number'] = artifact['build.parentNumber']
        }
        if (artifact['build.name'] && artifact['build.number']) {
          releaseArtifacts['zowe']['buildName'] = artifact['build.name']
          releaseArtifacts['zowe']['buildNumber'] = artifact['build.number']
        } else {
          // build info is required to get commit hash
          error "Cannot find build information for artifact ${params.ZOWE_BUILD_RC_PATH}"
        }
      } else {
        releaseArtifacts['zowe']['buildName'] = params.ZOWE_BUILD_NAME
        releaseArtifacts['zowe']['buildNumber'] = params.ZOWE_BUILD_NUMBER
      }

      // get zowe build source artifact
      releaseArtifacts['zowe']['source'] = pipeline.artifactory.getArtifact([
        'pattern'      : "${params.ZOWE_BUILD_REPOSITORY}/*/zowe-*.pax",
        'build-name'   : releaseArtifacts['zowe']['buildName'],
        'build-number' : releaseArtifacts['zowe']['buildNumber']
      ])
      echo ">>> Found Zowe build ${releaseArtifacts['zowe']['source']['path']}."

      // try to get Zowe build commit hash
      def zoweBuildInfo = pipeline.artifactory.getBuildInfo(
        releaseArtifacts['zowe']['buildName'],
        releaseArtifacts['zowe']['buildNumber']
      )
      releaseArtifacts['zowe']['revision'] = zoweBuildInfo && zoweBuildInfo['vcsRevision']
      if (!("${releaseArtifacts['zowe']['revision']}" ==~ /^[0-9a-fA-F]{40}$/)) { // if it's a SHA-1 commit hash
        error "Cannot extract git revision from build \"${releaseArtifacts['zowe']['buildName']}/${releaseArtifacts['zowe']['buildNumber']}\""
      }
      echo ">>>> Build ${releaseArtifacts['zowe']['buildName']}/${releaseArtifacts['zowe']['buildNumber']} commit hash is ${releaseArtifacts['zowe']['revision']}, may proceed."

      // get SMP/e build
      try {
        def smpePaxSource = pipeline.artifactory.getArtifact([
          'pattern'      : "${params.ZOWE_BUILD_REPOSITORY}/*/AZWE*.pax.Z",
          'build-name'   : releaseArtifacts['zowe']['buildName'],
          'build-number' : releaseArtifacts['zowe']['buildNumber']
        ])
        if (smpePaxSource['path']) {
          echo ">>> Found SMP/e build ${smpePaxSource['path']}."
          def FMID = smpePaxSource['path'].split('/').last().split('-').first()
          releaseArtifacts['smpe-pax'] = [:]
          releaseArtifacts['smpe-pax']['source'] = smpePaxSource
          releaseArtifacts['smpe-pax']['target'] = "${FMID}-${params.ZOWE_RELEASE_VERSION}.pax.Z".toString()
        }
      } catch (e1) {
        echo ">>> no SMP/e pax.Z found in the build."
      }

      // get SMP/e readme
      try {
        def smpeReadmeSource = pipeline.artifactory.getArtifact([
          'pattern'      : "${params.ZOWE_BUILD_REPOSITORY}/*/AZWE*.txt",
          'build-name'   : releaseArtifacts['zowe']['buildName'],
          'build-number' : releaseArtifacts['zowe']['buildNumber']
        ])
        if (smpeReadmeSource['path']) {
          echo ">>> Found SMP/e readme ${smpeReadmeSource['path']}."
          def FMID = smpeReadmeSource['path'].split('/').last().split('-').first()
          releaseArtifacts['smpe-readme'] = [:]
          releaseArtifacts['smpe-readme']['source'] = smpeReadmeSource
          releaseArtifacts['smpe-readme']['target'] = "${FMID}-${params.ZOWE_RELEASE_VERSION}.txt".toString()
        }
      } catch (e1) {
        echo ">>> no SMP/e readme found in the build."
      }

      // find the Zowe CLI build number will be promoted
      releaseArtifacts['cli'] = [:]
      releaseArtifacts['cli']['target'] = "zowe-cli-package-${params.ZOWE_RELEASE_VERSION}.zip".toString()
      if (params.ZOWE_CLI_BUILD_RC_PATH) {
        def artifact = pipeline.artifactory.getArtifact(params.ZOWE_CLI_BUILD_RC_PATH)
        if (artifact['build.name'].contains('zowe-promote-publish') &&
          artifact['build.parentName'] && artifact['build.parentNumber']) {
          artifact['build.name'] = artifact['build.parentName']
          artifact['build.number'] = artifact['build.parentNumber']
        }
        if (artifact['build.name'] && artifact['build.number']) {
          releaseArtifacts['cli']['buildName'] = artifact['build.name']
          releaseArtifacts['cli']['buildNumber'] = artifact['build.number']
        } else {
          error "Cannot find build information for artifact ${params.ZOWE_CLI_BUILD_RC_PATH}"
        }
      } else {
        releaseArtifacts['cli']['buildName'] = params.ZOWE_CLI_BUILD_NAME
        releaseArtifacts['cli']['buildNumber'] = params.ZOWE_CLI_BUILD_NUMBER
      }

      // get CLI build source artifact
      releaseArtifacts['cli']['source'] = pipeline.artifactory.getArtifact([
        'pattern'      : "${params.ZOWE_CLI_BUILD_REPOSITORY}/*/zowe-cli-package-*.zip",
        'build-name'   : releaseArtifacts['cli']['buildName'],
        'build-number' : releaseArtifacts['cli']['buildNumber']
      ])
      echo ">>> Found Zowe CLI build ${releaseArtifacts['cli']['source']['path']}."

      // try to get Zowe CLI build commit hash
      def cliBuildInfo = pipeline.artifactory.getBuildInfo(
        releaseArtifacts['cli']['buildName'],
        releaseArtifacts['cli']['buildNumber']
      )
      releaseArtifacts['cli']['revision'] = cliBuildInfo && cliBuildInfo['vcsRevision']
      if (!("${releaseArtifacts['cli']['revision']}" ==~ /^[0-9a-fA-F]{40}$/)) { // if it's a SHA-1 commit hash
        error "Cannot extract git revision from build \"${releaseArtifacts['cli']['buildName']}/${releaseArtifacts['cli']['buildNumber']}\""
      }
      echo ">>>> Build ${releaseArtifacts['cli']['buildName']}/${releaseArtifacts['cli']['buildNumber']} commit hash is ${releaseArtifacts['cli']['revision']}, may proceed."

      // check publish target directory
      withCredentials([usernamePassword(credentialsId: params.PUBLISH_SSH_CREDENTIAL, passwordVariable: 'PASSWORD', usernameVariable: 'USERNAME')]) {
        // move to target folder, split and generate hash
        def versionOnPublishDir = sh(script:"""SSHPASS=${PASSWORD} sshpass -e ssh -tt -o StrictHostKeyChecking=no -o PubkeyAuthentication=no -p ${params.PUBLISH_SSH_PORT} ${USERNAME}@${params.PUBLISH_SSH_HOST} << EOF
[ -d '${params.PUBLISH_DIRECTORY}/${params.ZOWE_RELEASE_CATEGORY}/${params.ZOWE_RELEASE_VERSION}' ] && exit 1
exit 0
EOF""", returnStatus:true)
        echo "Exit code: ${versionOnPublishDir}"
        if ("${versionOnPublishDir}" == "1") {
          error "Zowe version ${params.ZOWE_RELEASE_VERSION} already exists (${params.PUBLISH_DIRECTORY}/${params.ZOWE_RELEASE_CATEGORY}/${params.ZOWE_RELEASE_VERSION})"
        } else {
          echo ">>>> Target publish folder doesn't exist, may proceed."
        }
      }
    }
  )

  pipeline.createStage(
    name          : "Promote",
    isSkippable   : true,
    stage         : {
      // debug show releaseArtifacts
      writeJSON file: '.tmp-release-artifacts.json', json: releaseArtifacts, pretty: 2
      sh '''
set +x
echo All artifacts will be promoted:
echo ===============================================
cat .tmp-release-artifacts.json
echo
echo ===============================================
'''

      releaseArtifacts.each { artifact, info ->
        echo ">>> Promoting ${artifact} ..."
        pipeline.artifactory.promote([
          'source': info['source'],
          'targetPath': releaseFilePath,
          'targetName': info['target']
        ])
      }
    },
    timeout: [time: 10, unit: 'MINUTES']
  )

  pipeline.createStage(
    name          : "Sign",
    isSkippable   : true,
    stage         : {
      def signing = lib.package.Signing.new(this)
      sh 'mkdir -p .signing'
      def uploadArtifacts = readJSON(text:'{"files":[]}')

      releaseArtifacts.each { artifact, info ->
        echo ">>> Downloading ${releaseFilePath}/${info['target']} ..."
        pipeline.artifactory.download(
          specContent : "{\"files\":[{\"pattern\": \"${releaseFilePath}/${info['target']}\",\"target\":\".signing/\",\"flat\":\"true\"}]}",
          expected    : 1
        )

        echo ">>> Signing ${info['target']} ..."
        signing.sign(".signing/${info['target']}")
        uploadArtifacts['files'].push([
          "pattern" : ".signing/${info['target']}.asc".toString(),
          "target"  : releaseFilePath + '/'
        ])

        echo ">>> Generate hash of ${info['target']} ..."
        signing.hash(".signing/${info['target']}")
        uploadArtifacts['files'].push([
          "pattern" : ".signing/${info['target']}.sha512".toString(),
          "target"  : releaseFilePath + '/'
        ])
      }

      // debug show uploadArtifacts
      writeJSON file: '.tmp-upload-artifacts.json', json: uploadArtifacts, pretty: 2
      sh '''
set +x
echo All signing results:
echo ===============================================
cat .tmp-upload-artifacts.json
echo
echo ===============================================
'''

        echo ">>> Uploading signing results ..."
        pipeline.artifactory.upload([spec: '.tmp-upload-artifacts.json'])
    },
    timeout: [time: 10, unit: 'MINUTES']
  )

  pipeline.end()
}
